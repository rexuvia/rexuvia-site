<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lava Flow - Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            color: #fff;
        }
        
        #gameCanvas {
            flex: 1;
            display: block;
            cursor: crosshair;
            transition: cursor 0.1s ease;
        }

        #gameCanvas.pouring {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><circle cx="16" cy="16" r="8" fill="orange" opacity="0.8"/><circle cx="16" cy="16" r="6" fill="yellow"/></svg>') 16 16, crosshair;
        }
        
        /* UI Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 0.3s ease;
        }
        
        .overlay.active {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16162a 100%);
            border: 2px solid #ff6600;
            border-radius: 20px;
            padding: 40px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 102, 0, 0.5);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal h1 {
            color: #ff6600;
            text-align: center;
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
        }
        
        .modal h2 {
            color: #ffaa44;
            text-align: center;
            font-size: 2em;
            margin-bottom: 20px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(135deg, #ff6600, #ff0000);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 102, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 102, 0, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 30px 0;
            max-width: 900px;
        }
        
        .level-card {
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #444;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .level-card:hover:not(.locked) {
            border-color: #ff6600;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }
        
        .level-card.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .level-card h3 {
            color: #ff6600;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .level-card .stars {
            font-size: 1.5em;
            margin: 10px 0;
            color: #ffaa44;
        }
        
        .level-card .score {
            color: #aaa;
            font-size: 0.9em;
        }
        
        .act-separator {
            grid-column: 1 / -1;
            text-align: center;
            color: #ffaa44;
            font-size: 1.5em;
            margin: 10px 0;
            padding: 10px;
            border-bottom: 2px solid #ff6600;
        }
        
        /* HUD */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px;
            display: none;
            border-bottom: 2px solid #ff6600;
            z-index: 50;
        }
        
        .hud.active {
            display: block;
        }
        
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .hud-title {
            color: #ff6600;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .hud-controls button {
            padding: 10px 16px;
            font-size: 14px;
            margin-left: 8px;
        }
        
        .hud-info {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            color: #ffaa44;
        }
        
        .hud-stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .hud-stat #hudLava.low-budget {
            color: #ff3333;
            font-weight: bold;
            animation: pulse-red 0.8s ease-in-out infinite;
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .hud-objective {
            background: rgba(255, 102, 0, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #ff6600;
            font-size: 0.95em;
        }
        
        .stats-display {
            text-align: center;
            margin: 20px 0;
            color: #ffaa44;
        }
        
        .stats-display .big-stat {
            font-size: 2.5em;
            margin: 10px 0;
        }
        
        .stats-display .stars {
            font-size: 3em;
            color: #ffaa44;
        }
        
        .info-text {
            color: #aaa;
            text-align: center;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .tutorial-content {
            text-align: left;
            max-width: 600px;
            margin: 20px auto;
            line-height: 1.6;
        }

        .tutorial-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .tutorial-content li {
            margin-bottom: 8px;
            color: #ddd;
        }

        .tutorial-content strong {
            color: #ffaa44;
        }
        
        @media (max-width: 600px) {
            .modal {
                padding: 20px;
            }
            .modal h1 {
                font-size: 2em;
            }
            button {
                padding: 12px 20px;
                font-size: 14px;
            }
            .level-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 15px;
            }
            .hud-controls button {
                padding: 8px 12px;
                font-size: 12px;
                margin-left: 4px;
            }
            .hud-info {
                gap: 15px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD -->
    <div id="hud" class="hud">
        <div class="hud-top">
            <div class="hud-title" id="hudTitle">Level 1</div>
            <div class="hud-controls">
                <button id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button id="restartBtn">üîÑ Restart</button>
                <button id="menuBtn">üè† Menu</button>
            </div>
        </div>
        <div class="hud-info">
            <div class="hud-stat">
                <span>üåã Lava:</span>
                <span id="hudLava">0/50</span>
            </div>
            <div class="hud-stat" id="hudTimeContainer" style="display: none;">
                <span>‚è±Ô∏è Time:</span>
                <span id="hudTime">0s</span>
            </div>
            <div class="hud-stat">
                <span>üìä Score:</span>
                <span id="hudScore">0</span>
            </div>
            <div class="hud-stat">
                <span>‚≠ê Stars:</span>
                <span id="hudStars">0/3</span>
            </div>
        </div>
        <div class="hud-objective" id="hudObjective">
            Complete the objective
        </div>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseOverlay" class="overlay">
        <div class="modal">
            <h1>‚è∏Ô∏è PAUSED ‚è∏Ô∏è</h1>
            <div class="button-group">
                <button id="resumeBtn">‚ñ∂Ô∏è Resume</button>
                <button id="pauseRestartBtn">üîÑ Restart Level</button>
                <button id="pauseInstructionsBtn">üí° Instructions</button>
                <button id="pauseMenuBtn">üè† Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Instructions/How to Play -->
    <div id="instructionsOverlay" class="overlay">
        <div class="modal">
            <h1>How to Play üî•</h1>
            <div class="tutorial-content">
                <p>Welcome to Lava Flow! Your goal is to guide molten lava to achieve various objectives.</p>
                
                <h3 style="color: #ffaa44; margin-top: 15px;">Controls:</h3>
                <ul>
                    <li><strong>Pour Lava:</strong> Click and hold (or tap and hold on mobile) on the terrain to make lava erupt from that point. Release to stop pouring.</li>
                    <li><strong>Interact:</strong> Click or tap on interactive elements like gates to open or close them.</li>
                    <li><strong>Pause:</strong> Use the pause button in the HUD to temporarily stop the game and review instructions.</li>
                </ul>

                <h3 style="color: #ffaa44; margin-top: 15px;">Objective Types:</h3>
                <ul>
                    <li><strong>Fill Target:</strong> Fill designated zones (blue dashed circles) with a required amount of lava.</li>
                    <li><strong>Reach Point:</strong> Guide lava to specific beacon points (yellow circles).</li>
                    <li><strong>Collection:</strong> Fill basins to a precise target amount, avoiding overfilling.</li>
                    <li><strong>Connect:</strong> Create a continuous flow of lava between multiple points.</li>
                    <li><strong>Sequence:</strong> Activate targets in a specific order (numbered circles).</li>
                    <li><strong>Contain:</strong> Fill a target zone without letting lava spill into danger zones (red areas).</li>
                </ul>

                <h3 style="color: #ffaa44; margin-top: 15px;">Tips:</h3>
                <ul>
                    <li>Manage your lava budget (if applicable) wisely. Look at the HUD for budget display.</li>
                    <li>Observe the terrain layout and plan your lava flow before pouring.</li>
                    <li>Yellow circles on the terrain indicate restricted pour points - you can only pour from these areas in some levels.</li>
                    <li>When the lava budget is low (less than 25%), it will turn red and pulse as a warning.</li>
                    <li>Earn stars by completing levels efficiently and quickly. More stars unlock achievements!</li>
                </ul>
            </div>
            <div class="button-group">
                <button id="closeInstructionsBtn">Got It!</button>
            </div>
        </div>
    </div>

    <!-- Level 1 Tutorial -->
    <div id="level1TutorialOverlay" class="overlay">
        <div class="modal">
            <h1>üåã Welcome, Volcanologist! üåã</h1>
            <div class="tutorial-content" style="text-align: center;">
                <p style="font-size: 1.1em; margin: 20px 0;">In this first level, you'll learn the basics of lava control.</p>
                
                <h3 style="color: #ffaa44; margin-top: 20px;">Your Goal:</h3>
                <p style="font-size: 1.05em;">Fill the glowing blue target zone with lava.</p>
                
                <h3 style="color: #ffaa44; margin-top: 20px;">How to Pour Lava:</h3>
                <p>Click and hold your mouse (or tap and hold on mobile) anywhere on the terrain to make lava erupt. The cursor will glow when you're pouring!</p>
                <p style="margin-top: 10px; color: #ffbb66;">Release to stop pouring and observe how the lava flows down the terrain.</p>
            </div>
            <div class="button-group">
                <button id="startLevel1TutorialBtn">‚ú® Got It! Start Level ‚ú®</button>
            </div>
        </div>
    </div>
    
    <!-- Main Menu -->
    <div id="menuOverlay" class="overlay active">
        <div class="modal">
            <h1>üî• LAVA FLOW üî•</h1>
            <p style="text-align: center; color: #ffbb66; margin-bottom: 20px;">Guide the molten rock to victory!</p>
            <div class="button-group">
                <button id="continueBtn">‚ñ∂Ô∏è Continue</button>
                <button id="levelSelectBtn">üìã Level Select</button>
                <button id="sandboxBtn">üèúÔ∏è Sandbox Mode</button>
                <button id="instructionsBtn">üìñ Instructions</button>
            </div>
            <div class="info-text" id="menuStars">Total Stars: ‚≠ê 0</div>
        </div>
    </div>
    
    <!-- Level Select -->
    <div id="levelSelectOverlay" class="overlay">
        <div class="modal">
            <h1>üìä Select Level</h1>
            <div class="level-grid" id="levelGrid"></div>
            <div class="button-group">
                <button id="backToMenuBtn">‚Ü©Ô∏è Back to Menu</button>
            </div>
        </div>
    </div>
    
    <!-- Victory Screen -->
    <div id="victoryOverlay" class="overlay">
        <div class="modal">
            <h1>üéâ LEVEL COMPLETE! üéâ</h1>
            <div class="stats-display">
                <div class="stars" id="victoryStars">‚≠ê‚≠ê‚≠ê</div>
                <div class="big-stat">Score: <span id="victoryScore">0</span></div>
                <div id="victoryBest" style="color: #888;">Best: 0</div>
                <div style="margin-top: 20px;">
                    <div>‚ö° Efficiency: <span id="victoryEfficiency">0%</span></div>
                    <div id="victoryTimeDiv">‚è±Ô∏è Time: <span id="victoryTime">0s</span></div>
                </div>
            </div>
            <div class="button-group">
                <button id="nextLevelBtn">‚û°Ô∏è Next Level</button>
                <button id="retryBtn">üîÑ Retry</button>
                <button id="victoryMenuBtn">üè† Menu</button>
            </div>
        </div>
    </div>
    
    <!-- Defeat Screen -->
    <div id="defeatOverlay" class="overlay">
        <div class="modal">
            <h1>üíÄ LEVEL FAILED üíÄ</h1>
            <h2 id="defeatReason" style="color: #ff6666;">Lava budget exhausted</h2>
            <div class="button-group">
                <button id="defeatRetryBtn">üîÑ Retry</button>
                <button id="defeatMenuBtn">üè† Menu</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME STATE ====================
        
        const GameState = {
            MENU: 'menu',
            LEVEL_SELECT: 'levelSelect',
            PLAYING: 'playing',
            PAUSED: 'paused',
            VICTORY: 'victory',
            DEFEAT: 'defeat',
            SANDBOX: 'sandbox'
        };
        
        let gameState = {
            mode: GameState.MENU,
            currentLevel: 0,
            progress: {
                lavaUsed: 0,
                timeElapsed: 0,
                objectivesCompleted: [],
                score: 0,
                level1TutorialShown: false
            },
            unlockedLevels: [1],
            starsPerLevel: {},
            scorePerLevel: {}
        };
        
        // ==================== LEVEL DEFINITIONS ====================
        
        const levels = [
            // ACT I: IGNITION
            {
                id: 1,
                name: "First Pour",
                act: "First Eruption",
                terrain: 'valley',
                objective: {
                    type: 'FILL_TARGET',
                    description: 'Fill the target zone with lava',
                    zones: [{ x: 60, y: 80, radius: 15, required: 8 }]
                },
                constraints: {
                    budget: Infinity,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [1000, 1500, 2000],
                hint: "Click and hold to pour lava. Guide it into the glowing blue circle!"
            },
            {
                id: 2,
                name: "The Beacon",
                act: "First Eruption",
                terrain: 'slope',
                objective: {
                    type: 'REACH_POINT',
                    description: 'Guide lava to the beacon',
                    points: [{ x: 90, y: 100 }]
                },
                constraints: {
                    budget: 60,
                    pourPoints: [{ x: 30, y: 30 }],
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [1200, 1800, 2400],
                hint: "You have a limited lava budget and can only pour from the highlighted yellow zone. Plan your flow carefully!"
            },
            {
                id: 3,
                name: "Conservation",
                act: "First Eruption",
                terrain: 'crater',
                objective: {
                    type: 'FILL_TARGET',
                    description: 'Fill the crater efficiently',
                    zones: [{ x: 60, y: 60, radius: 20, required: 12 }]
                },
                constraints: {
                    budget: 40,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [1500, 2200, 3000],
                hint: "Every drop counts! You have a very limited lava budget. Conserve wisely!"
            },
            {
                id: 4,
                name: "Twin Basins",
                act: "First Eruption",
                terrain: 'twinBasins',
                objective: {
                    type: 'COLLECTION',
                    description: 'Fill both basins evenly',
                    basins: [
                        { x: 40, y: 70, radius: 12, target: 6, tolerance: 0.15 },
                        { x: 80, y: 70, radius: 12, target: 6, tolerance: 0.15 }
                    ]
                },
                constraints: {
                    budget: 40,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [2000, 2800, 3500]
            },
            
            // ACT II: CONTROL
            {
                id: 5,
                name: "Bridge Builder",
                act: "Controlled Burn",
                terrain: 'gap',
                objective: {
                    type: 'CONNECT',
                    description: 'Connect the two beacons',
                    points: [{ x: 30, y: 60 }, { x: 90, y: 60 }]
                },
                constraints: {
                    budget: 50,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [
                    { type: 'barrier', x: 55, y: 50, width: 3, height: 20 }
                ],
                starThresholds: [2200, 3000, 3800]
            },
            {
                id: 6,
                name: "Time Trial",
                act: "Controlled Burn",
                terrain: 'steps',
                objective: {
                    type: 'COLLECTION',
                    description: 'Fill basins quickly',
                    basins: [
                        { x: 35, y: 80, radius: 10, target: 5, tolerance: 0.15 },
                        { x: 85, y: 80, radius: 10, target: 5, tolerance: 0.15 }
                    ]
                },
                constraints: {
                    budget: 35,
                    pourPoints: null,
                    timeLimit: 90
                },
                interactive: [],
                starThresholds: [2500, 3300, 4200]
            },
            {
                id: 7,
                name: "The Waterfall",
                act: "Controlled Burn",
                terrain: 'waterfall',
                objective: {
                    type: 'REACH_POINT',
                    description: 'Reach the bottom beacon',
                    points: [{ x: 60, y: 100 }]
                },
                constraints: {
                    budget: 45,
                    pourPoints: [{ x: 60, y: 20 }],
                    timeLimit: null
                },
                interactive: [
                    { type: 'barrier', x: 50, y: 55, width: 20, height: 3 }
                ],
                starThresholds: [2800, 3600, 4500]
            },
            {
                id: 8,
                name: "The Valve",
                act: "Controlled Burn",
                terrain: 'funnel',
                objective: {
                    type: 'CONNECT',
                    description: 'Connect all three beacons',
                    points: [{ x: 30, y: 40 }, { x: 90, y: 40 }, { x: 60, y: 90 }]
                },
                constraints: {
                    budget: 55,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [
                    { type: 'gate', x: 60, y: 60, width: 8, height: 3, open: false }
                ],
                starThresholds: [3000, 4000, 5000]
            },
            
            // ACT III: MASTERY
            {
                id: 9,
                name: "Chain Reaction",
                act: "Volcanic Mastery",
                terrain: 'sequence',
                objective: {
                    type: 'SEQUENCE',
                    description: 'Activate targets in order: 1 ‚Üí 2 ‚Üí 3',
                    sequence: [
                        { x: 40, y: 50, order: 1, timeWindow: 20 },
                        { x: 60, y: 70, order: 2, timeWindow: 20 },
                        { x: 80, y: 50, order: 3, timeWindow: 20 }
                    ]
                },
                constraints: {
                    budget: 40,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [3500, 4500, 5500]
            },
            {
                id: 10,
                name: "Forbidden Valley",
                act: "Volcanic Mastery",
                terrain: 'narrow',
                objective: {
                    type: 'CONTAIN',
                    description: 'Fill target without spilling into danger zones',
                    target: { x: 60, y: 80, radius: 15, required: 8 },
                    dangerZones: [
                        { x: 30, y: 80, radius: 18 },
                        { x: 90, y: 80, radius: 18 }
                    ]
                },
                constraints: {
                    budget: 30,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [],
                starThresholds: [4000, 5000, 6000]
            },
            {
                id: 11,
                name: "Double Duty",
                act: "Volcanic Mastery",
                terrain: 'complex',
                objective: {
                    type: 'MULTI',
                    description: 'Fill basin AND connect beacons',
                    objectives: [
                        {
                            type: 'COLLECTION',
                            basins: [{ x: 40, y: 60, radius: 12, target: 8, tolerance: 0.15 }]
                        },
                        {
                            type: 'CONNECT',
                            points: [{ x: 80, y: 40 }, { x: 80, y: 80 }]
                        }
                    ]
                },
                constraints: {
                    budget: 50,
                    pourPoints: null,
                    timeLimit: 120
                },
                interactive: [
                    { type: 'barrier', x: 65, y: 30, width: 3, height: 60 }
                ],
                starThresholds: [4500, 5500, 7000]
            },
            {
                id: 12,
                name: "The Volcano's Heart",
                act: "Volcanic Mastery",
                terrain: 'finale',
                objective: {
                    type: 'SEQUENCE_CONTAIN',
                    description: 'Activate in sequence without contamination',
                    sequence: [
                        { x: 30, y: 40, order: 1, timeWindow: 25 },
                        { x: 90, y: 40, order: 2, timeWindow: 25 },
                        { x: 60, y: 70, order: 3, timeWindow: 25 },
                        { x: 60, y: 100, order: 4, timeWindow: 25 }
                    ],
                    dangerZones: [
                        { x: 60, y: 30, radius: 15 }
                    ]
                },
                constraints: {
                    budget: 60,
                    pourPoints: null,
                    timeLimit: null
                },
                interactive: [
                    { type: 'gate', x: 55, y: 55, width: 10, height: 3, open: false },
                    { type: 'gate', x: 55, y: 85, width: 10, height: 3, open: false }
                ],
                starThresholds: [5000, 6500, 8000]
            }
        ];
        
        // ==================== TERRAIN GENERATORS ====================
        
        const terrainGenerators = {
            valley: (x, y) => {
                const centerX = GRID_SIZE / 2;
                const distFromCenter = Math.abs(x - centerX);
                return Math.pow(distFromCenter / (GRID_SIZE / 2), 2) * 40 + 
                       Math.sin(y * 0.1) * 5 +
                       Math.random() * 3;
            },
            crater: (x, y) => {
                const centerX = GRID_SIZE / 2;
                const centerY = GRID_SIZE / 2;
                const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const maxDist = GRID_SIZE / 2;
                return Math.abs(Math.sin(dist / maxDist * Math.PI)) * 35 + Math.random() * 2;
            },
            slope: (x, y) => {
                return (x / GRID_SIZE) * 30 + Math.sin(y * 0.15) * 5 + Math.random() * 2;
            },
            steps: (x, y) => {
                return Math.floor(x / (GRID_SIZE / 5)) * 8 + Math.random() * 2;
            },
            funnel: (x, y) => {
                const centerX = GRID_SIZE / 2;
                const centerY = GRID_SIZE / 2;
                const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                return dist * 0.5 + Math.random() * 2;
            },
            twinBasins: (x, y) => {
                const basin1X = GRID_SIZE / 3;
                const basin2X = (GRID_SIZE / 3) * 2;
                const basinY = (GRID_SIZE / 4) * 3;
                const dist1 = Math.sqrt(Math.pow(x - basin1X, 2) + Math.pow(y - basinY, 2));
                const dist2 = Math.sqrt(Math.pow(x - basin2X, 2) + Math.pow(y - basinY, 2));
                return Math.min(dist1, dist2) * 0.8 + Math.random() * 2;
            },
            gap: (x, y) => {
                if (x > GRID_SIZE / 2 - 5 && x < GRID_SIZE / 2 + 5) {
                    return 30 + Math.random() * 2;
                }
                return (Math.abs(x - GRID_SIZE / 2) / GRID_SIZE) * 20 + Math.random() * 2;
            },
            waterfall: (x, y) => {
                return (y / GRID_SIZE) * 40 + Math.sin(x * 0.2) * 5 + Math.random() * 2;
            },
            sequence: (x, y) => {
                return Math.sin(x * 0.15) * 10 + Math.cos(y * 0.15) * 10 + 15 + Math.random() * 2;
            },
            narrow: (x, y) => {
                const centerX = GRID_SIZE / 2;
                const distFromCenter = Math.abs(x - centerX);
                if (distFromCenter < 15) {
                    return (y / GRID_SIZE) * 25 + Math.random() * 2;
                }
                return (y / GRID_SIZE) * 25 + 20 + Math.random() * 2;
            },
            complex: (x, y) => {
                return Math.sin(x * 0.1) * 15 + Math.cos(y * 0.1) * 10 + 15 + Math.random() * 3;
            },
            finale: (x, y) => {
                const sectors = Math.floor(y / (GRID_SIZE / 4));
                return sectors * 10 + Math.sin(x * 0.2) * 8 + Math.random() * 2;
            }
        };
        
        // ==================== CANVAS & SIMULATION ====================
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const GRID_SIZE = 120;
        let terrain = [];
        let lava = [];
        let temperature = [];
        let particles = [];
        let interactiveElements = [];
        
        let isPouring = false;
        let pourX = 0;
        let pourY = 0;
        let validPourPoints = null;
        
        let gameTime = 0;
        let lastFrameTime = Date.now();
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        function initGrids() {
            terrain = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            lava = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            temperature = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        }
        
        function generateTerrain(generatorName) {
            const generator = terrainGenerators[generatorName] || terrainGenerators.valley;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    terrain[y][x] = generator(x, y);
                }
            }
            smoothTerrain();
        }
        
        function smoothTerrain() {
            const newTerrain = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    let sum = 0;
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            sum += terrain[y + dy][x + dx];
                            count++;
                        }
                    }
                    newTerrain[y][x] = sum / count;
                }
            }
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    terrain[y][x] = newTerrain[y][x];
                }
            }
        }
        
        // Particle system
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4 - 2;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = 2 + Math.random() * 3;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life -= this.decay;
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        // Lava simulation
        function simulateLava() {
            const newLava = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            const newTemperature = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    if (lava[y][x] > 0.01) {
                        const currentHeight = terrain[y][x] + lava[y][x];
                        let remaining = lava[y][x];
                        
                        // Check barriers
                        let blocked = false;
                        for (const elem of interactiveElements) {
                            if (elem.type === 'barrier' || (elem.type === 'gate' && !elem.open)) {
                                if (x >= elem.x && x < elem.x + elem.width &&
                                    y >= elem.y && y < elem.y + elem.height) {
                                    blocked = true;
                                    break;
                                }
                            }
                        }
                        
                        if (blocked) {
                            newLava[y][x] += lava[y][x];
                            newTemperature[y][x] = temperature[y][x] * 0.995;
                            continue;
                        }
                        
                        const neighbors = [
                            { dx: 0, dy: -1 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                            { dx: 1, dy: 0 },
                            { dx: -1, dy: -1 },
                            { dx: 1, dy: -1 },
                            { dx: -1, dy: 1 },
                            { dx: 1, dy: 1 }
                        ];
                        
                        const flows = [];
                        
                        for (const { dx, dy } of neighbors) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            // Check if neighbor is blocked
                            let neighborBlocked = false;
                            for (const elem of interactiveElements) {
                                if (elem.type === 'barrier' || (elem.type === 'gate' && !elem.open)) {
                                    if (nx >= elem.x && nx < elem.x + elem.width &&
                                        ny >= elem.y && ny < elem.y + elem.height) {
                                        neighborBlocked = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (neighborBlocked) continue;
                            
                            const neighborHeight = terrain[ny][nx] + lava[ny][nx];
                            const heightDiff = currentHeight - neighborHeight;
                            
                            if (heightDiff > 0) {
                                const flowRate = Math.min(heightDiff * 0.3, remaining * 0.8);
                                const diagonalFactor = (dx !== 0 && dy !== 0) ? 0.7 : 1.0;
                                flows.push({ nx, ny, amount: flowRate * diagonalFactor });
                            }
                        }
                        
                        let totalFlow = flows.reduce((sum, f) => sum + f.amount, 0);
                        
                        if (totalFlow > 0) {
                            const flowScale = Math.min(1, remaining / totalFlow);
                            for (const { nx, ny, amount } of flows) {
                                const actualFlow = amount * flowScale;
                                newLava[ny][nx] += actualFlow;
                                newTemperature[ny][nx] = Math.max(newTemperature[ny][nx], temperature[y][x]);
                                remaining -= actualFlow;
                                
                                if (Math.random() < 0.05 && temperature[y][x] > 0.7) {
                                    const cellSize = Math.min(canvas.width, canvas.height) / GRID_SIZE;
                                    particles.push(new Particle(
                                        nx * cellSize + cellSize / 2,
                                        ny * cellSize + cellSize / 2
                                    ));
                                }
                            }
                        }
                        
                        newLava[y][x] += remaining;
                        newTemperature[y][x] = Math.max(newTemperature[y][x], temperature[y][x] * 0.995);
                    }
                }
            }
            
            lava = newLava;
            temperature = newTemperature;
            
            particles = particles.filter(p => {
                p.update();
                return !p.isDead();
            });
        }
        
        function pourLava(screenX, screenY) {
            const cellSize = Math.min(canvas.width, canvas.height) / GRID_SIZE;
            const offsetX = (canvas.width - GRID_SIZE * cellSize) / 2;
            const offsetY = (canvas.height - GRID_SIZE * cellSize) / 2;
            
            const gridX = Math.floor((screenX - offsetX) / cellSize);
            const gridY = Math.floor((screenY - offsetY) / cellSize);
            
            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                // Check pour point restrictions
                if (validPourPoints) {
                    let canPour = false;
                    for (const pp of validPourPoints) {
                        const dist = Math.sqrt(Math.pow(gridX - pp.x, 2) + Math.pow(gridY - pp.y, 2));
                        if (dist < 8) {
                            canPour = true;
                            break;
                        }
                    }
                    if (!canPour) return;
                }
                
                lava[gridY][gridX] += 0.5;
                temperature[gridY][gridX] = 1.0;
                gameState.progress.lavaUsed += 0.5;
                
                if (Math.random() < 0.3) {
                    particles.push(new Particle(screenX, screenY));
                }
            }
        }
        
        function getColorForLava(temp) {
            if (temp > 0.9) return `rgb(255, 255, ${Math.floor(255 * (1 - temp))})`;
            if (temp > 0.7) return `rgb(255, ${Math.floor(255 * (temp - 0.7) / 0.2)}, 0)`;
            if (temp > 0.5) return `rgb(255, ${Math.floor(102 * (temp - 0.5) / 0.2)}, 0)`;
            if (temp > 0.3) return `rgb(255, 0, 0)`;
            if (temp > 0.1) return `rgb(${Math.floor(136 + (255 - 136) * (temp - 0.1) / 0.2)}, 0, 0)`;
            return `rgb(${Math.floor(136 * temp / 0.1)}, 0, 0)`;
        }
        
        function render() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = Math.min(canvas.width, canvas.height) / GRID_SIZE;
            const offsetX = (canvas.width - GRID_SIZE * cellSize) / 2;
            const offsetY = (canvas.height - GRID_SIZE * cellSize) / 2;
            
            // Render terrain
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const height = terrain[y][x];
                    const brightness = 26 + Math.floor(height * 0.8);
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness + 20})`;
                    ctx.fillRect(
                        offsetX + x * cellSize,
                        offsetY + y * cellSize,
                        cellSize + 1,
                        cellSize + 1
                    );
                }
            }
            
            // Render objective overlays
            if (gameState.mode === GameState.PLAYING || gameState.mode === GameState.PAUSED) {
                renderObjectives(offsetX, offsetY, cellSize);
            }
            
            // Render interactive elements
            for (const elem of interactiveElements) {
                if (elem.type === 'barrier') {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(
                        offsetX + elem.x * cellSize,
                        offsetY + elem.y * cellSize,
                        elem.width * cellSize,
                        elem.height * cellSize
                    );
                } else if (elem.type === 'gate') {
                    ctx.fillStyle = elem.open ? '#00ff00' : '#ff0000';
                    ctx.globalAlpha = 0.6;
                    ctx.fillRect(
                        offsetX + elem.x * cellSize,
                        offsetY + elem.y * cellSize,
                        elem.width * cellSize,
                        elem.height * cellSize
                    );
                    ctx.globalAlpha = 1;
                    
                    // Draw button indicator
                    ctx.fillStyle = elem.open ? '#00ff00' : '#ff0000';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + (elem.x + elem.width / 2) * cellSize,
                        offsetY + (elem.y + elem.height / 2) * cellSize,
                        cellSize * 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Render pour points with enhanced visual feedback
            if (validPourPoints && (gameState.mode === GameState.PLAYING || gameState.mode === GameState.PAUSED)) {
                ctx.save();
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 8]);
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 170, 0, 0.8)';
                
                for (const pp of validPourPoints) {
                    const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7; // Pulsating effect
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + pp.x * cellSize,
                        offsetY + pp.y * cellSize,
                        10 * cellSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Draw a small solid circle in the center
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + pp.x * cellSize,
                        offsetY + pp.y * cellSize,
                        cellSize * 2.5,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
            }
            
            // Render lava with glow
            ctx.save();
            ctx.shadowBlur = 15;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (lava[y][x] > 0.01) {
                        const temp = temperature[y][x];
                        const alpha = Math.min(1, lava[y][x]);
                        
                        ctx.shadowColor = temp > 0.7 ? '#ff6600' : '#880000';
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = getColorForLava(temp);
                        ctx.fillRect(
                            offsetX + x * cellSize,
                            offsetY + y * cellSize,
                            cellSize + 1,
                            cellSize + 1
                        );
                    }
                }
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
            
            // Render particles
            for (const particle of particles) {
                const alpha = particle.life;
                const temp = particle.life;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = getColorForLava(temp);
                ctx.beginPath();
                ctx.arc(
                    offsetX + particle.x,
                    offsetY + particle.y,
                    particle.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function renderObjectives(offsetX, offsetY, cellSize) {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return;
            
            const obj = level.objective;
            
            ctx.save();
            
            if (obj.type === 'FILL_TARGET' || obj.type === 'CONTAIN') {
                const zones = obj.zones || [obj.target];
                for (const zone of zones) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + zone.x * cellSize,
                        offsetY + zone.y * cellSize,
                        zone.radius * cellSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();

                    // Fill progress indicator
                    const currentAmount = checkLavaInZone(zone.x, zone.y, zone.radius);
                    const fillRatio = Math.min(1, currentAmount / zone.required);

                    if (fillRatio > 0) {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                        ctx.beginPath();
                        ctx.arc(
                            offsetX + zone.x * cellSize,
                            offsetY + zone.y * cellSize,
                            zone.radius * cellSize * fillRatio,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                if (obj.dangerZones) {
                    for (const dz of obj.dangerZones) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(
                            offsetX + dz.x * cellSize,
                            offsetY + dz.y * cellSize,
                            dz.radius * cellSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
            
            if (obj.type === 'REACH_POINT' || obj.type === 'CONNECT') {
                for (const point of obj.points) {
                    const reached = checkLavaAtPoint(point.x, point.y);
                    ctx.fillStyle = reached ? '#00ff00' : '#ffff00';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = reached ? '#00ff00' : '#ffff00';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + point.x * cellSize,
                        offsetY + point.y * cellSize,
                        cellSize * 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.stroke();
                    
                    // Pulse effect
                    ctx.strokeStyle = reached ? '#00ff00' : '#ffff00';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.005) * 0.5;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + point.x * cellSize,
                        offsetY + point.y * cellSize,
                        cellSize * 5,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            if (obj.type === 'COLLECTION') {
                for (const basin of obj.basins) {
                    const amount = checkLavaInZone(basin.x, basin.y, basin.radius);
                    const filled = amount / basin.target;
                    
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + basin.x * cellSize,
                        offsetY + basin.y * cellSize,
                        basin.radius * cellSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Fill meter
                    ctx.fillStyle = filled >= 1 - basin.tolerance && filled <= 1 + basin.tolerance ? '#00ff00' : '#ffaa00';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.fillText(
                        `${amount.toFixed(1)}/${basin.target}`,
                        offsetX + basin.x * cellSize - 30,
                        offsetY + basin.y * cellSize + 5
                    );
                }
            }
            
            if (obj.type === 'SEQUENCE' || obj.type === 'SEQUENCE_CONTAIN') {
                for (const target of obj.sequence) {
                    const activated = gameState.progress.objectivesCompleted.includes(target.order);
                    const active = gameState.progress.objectivesCompleted.length + 1 === target.order;
                    
                    ctx.fillStyle = activated ? '#00ff00' : (active ? '#ffaa00' : '#888888');
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = activated ? '#00ff00' : (active ? '#ffaa00' : '#666666');
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + target.x * cellSize,
                        offsetY + target.y * cellSize,
                        cellSize * 4,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        target.order.toString(),
                        offsetX + target.x * cellSize,
                        offsetY + target.y * cellSize
                    );
                }
            }
            
            if (obj.type === 'MULTI') {
                // Render both objectives
                for (const subObj of obj.objectives) {
                    if (subObj.type === 'COLLECTION') {
                        for (const basin of subObj.basins) {
                            const amount = checkLavaInZone(basin.x, basin.y, basin.radius);
                            ctx.strokeStyle = '#00ffff';
                            ctx.lineWidth = 3;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.arc(
                                offsetX + basin.x * cellSize,
                                offsetY + basin.y * cellSize,
                                basin.radius * cellSize,
                                0,
                                Math.PI * 2
                            );
                            ctx.stroke();
                            
                            ctx.fillStyle = '#ffaa00';
                            ctx.font = '14px sans-serif';
                            ctx.fillText(
                                `${amount.toFixed(1)}/${basin.target}`,
                                offsetX + basin.x * cellSize - 20,
                                offsetY + basin.y * cellSize
                            );
                        }
                    }
                    if (subObj.type === 'CONNECT') {
                        for (const point of subObj.points) {
                            const reached = checkLavaAtPoint(point.x, point.y);
                            ctx.fillStyle = reached ? '#00ff00' : '#ffff00';
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(
                                offsetX + point.x * cellSize,
                                offsetY + point.y * cellSize,
                                cellSize * 3,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            }
            
            ctx.restore();
            ctx.setLineDash([]);
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
        }
        
        // ==================== OBJECTIVE CHECKING ====================
        
        function checkLavaAtPoint(x, y) {
            const radius = 3;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const checkX = Math.floor(x + dx);
                    const checkY = Math.floor(y + dy);
                    if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
                        if (lava[checkY][checkX] > 0.1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function checkLavaInZone(x, y, radius) {
            let total = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const checkX = Math.floor(x + dx);
                        const checkY = Math.floor(y + dy);
                        if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
                            total += lava[checkY][checkX];
                        }
                    }
                }
            }
            return total;
        }
        
        function checkConnected(point1, point2) {
            // BFS to check if two points are connected via lava
            const visited = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
            const queue = [];
            
            // Find lava cells near point1
            let startFound = false;
            for (let dy = -3; dy <= 3 && !startFound; dy++) {
                for (let dx = -3; dx <= 3 && !startFound; dx++) {
                    const x = Math.floor(point1.x + dx);
                    const y = Math.floor(point1.y + dy);
                    if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && lava[y][x] > 0.1) {
                        queue.push({ x, y });
                        visited[y][x] = true;
                        startFound = true;
                    }
                }
            }
            
            if (!startFound) return false;
            
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                
                // Check if we reached point2
                const dist = Math.sqrt(Math.pow(x - point2.x, 2) + Math.pow(y - point2.y, 2));
                if (dist < 3) {
                    return true;
                }
                
                // Check neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE &&
                            !visited[ny][nx] && lava[ny][nx] > 0.1) {
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            
            return false;
        }
        
        function checkObjectiveComplete() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return false;
            
            const obj = level.objective;
            
            if (obj.type === 'FILL_TARGET') {
                for (const zone of obj.zones) {
                    const amount = checkLavaInZone(zone.x, zone.y, zone.radius);
                    if (amount < zone.required) return false;
                }
                return true;
            }
            
            if (obj.type === 'REACH_POINT') {
                for (const point of obj.points) {
                    if (!checkLavaAtPoint(point.x, point.y)) return false;
                }
                return true;
            }
            
            if (obj.type === 'COLLECTION') {
                for (const basin of obj.basins) {
                    const amount = checkLavaInZone(basin.x, basin.y, basin.radius);
                    const ratio = amount / basin.target;
                    if (ratio < 1 - basin.tolerance || ratio > 1 + basin.tolerance) {
                        return false;
                    }
                }
                return true;
            }
            
            if (obj.type === 'CONNECT') {
                for (let i = 0; i < obj.points.length - 1; i++) {
                    if (!checkConnected(obj.points[i], obj.points[i + 1])) {
                        return false;
                    }
                }
                return true;
            }
            
            if (obj.type === 'SEQUENCE' || obj.type === 'SEQUENCE_CONTAIN') {
                return gameState.progress.objectivesCompleted.length === obj.sequence.length;
            }
            
            if (obj.type === 'CONTAIN') {
                const targetAmount = checkLavaInZone(obj.target.x, obj.target.y, obj.target.radius);
                if (targetAmount < obj.target.required) return false;
                
                for (const dz of obj.dangerZones) {
                    const dangerAmount = checkLavaInZone(dz.x, dz.y, dz.radius);
                    if (dangerAmount > 0.5) return false;
                }
                return true;
            }
            
            if (obj.type === 'MULTI') {
                for (const subObj of obj.objectives) {
                    if (subObj.type === 'COLLECTION') {
                        for (const basin of subObj.basins) {
                            const amount = checkLavaInZone(basin.x, basin.y, basin.radius);
                            const ratio = amount / basin.target;
                            if (ratio < 1 - basin.tolerance || ratio > 1 + basin.tolerance) {
                                return false;
                            }
                        }
                    }
                    if (subObj.type === 'CONNECT') {
                        for (let i = 0; i < subObj.points.length - 1; i++) {
                            if (!checkConnected(subObj.points[i], subObj.points[i + 1])) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            return false;
        }
        
        function checkSequenceProgress() {
            const level = levels[gameState.currentLevel - 1];
            if (!level || (level.objective.type !== 'SEQUENCE' && level.objective.type !== 'SEQUENCE_CONTAIN')) return;
            
            const nextOrder = gameState.progress.objectivesCompleted.length + 1;
            const target = level.objective.sequence.find(t => t.order === nextOrder);
            
            if (target && checkLavaAtPoint(target.x, target.y)) {
                gameState.progress.objectivesCompleted.push(target.order);
            }
        }
        
        function checkDangerZones() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return false;
            
            const obj = level.objective;
            if (obj.dangerZones) {
                for (const dz of obj.dangerZones) {
                    const amount = checkLavaInZone(dz.x, dz.y, dz.radius);
                    if (amount > 0.5) return true;
                }
            }
            
            return false;
        }
        
        // ==================== SCORING ====================
        
        function calculateScore() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return 0;
            
            let score = 2000;
            
            if (level.constraints.budget !== Infinity) {
                const efficiency = 1 - (gameState.progress.lavaUsed / level.constraints.budget);
                if (efficiency > 0) {
                    score += Math.floor(efficiency * 2000);
                }
            }
            
            if (level.constraints.timeLimit) {
                const timeRemaining = level.constraints.timeLimit - gameState.progress.timeElapsed;
                if (timeRemaining > 0) {
                    score += Math.floor(timeRemaining * 10);
                }
            }
            
            return Math.max(0, score);
        }
        
        function getStarCount(score, thresholds) {
            if (score >= thresholds[2]) return 3;
            if (score >= thresholds[1]) return 2;
            if (score >= thresholds[0]) return 1;
            return 0;
        }
        
        // ==================== GAME STATE MANAGEMENT ====================
        
        function startLevel(levelId) {
            const level = levels[levelId - 1];
            if (!level) return;
            
            if (levelId === 1 && !gameState.progress.level1TutorialShown) {
                showLevel1Tutorial();
                return;
            }

            gameState.mode = GameState.PLAYING;
            gameState.currentLevel = levelId;
            gameState.progress = {
                lavaUsed: 0,
                timeElapsed: 0,
                objectivesCompleted: [],
                score: 0,
                level1TutorialShown: gameState.progress.level1TutorialShown
            };
            
            initGrids();
            generateTerrain(level.terrain);
            particles = [];
            interactiveElements = [...level.interactive];
            validPourPoints = level.constraints.pourPoints;
            gameTime = 0;
            
            document.getElementById('hud').classList.add('active');
            document.getElementById('hudTitle').textContent = `Level ${level.id}: ${level.name}`;
            document.getElementById('hudObjective').textContent = `üéØ ${level.objective.description}`;
            
            if (level.constraints.timeLimit) {
                document.getElementById('hudTimeContainer').style.display = 'flex';
            } else {
                document.getElementById('hudTimeContainer').style.display = 'none';
            }
            
            hideAllOverlays();
            updateHUD();
        }

        function showLevel1Tutorial() {
            hideAllOverlays();
            document.getElementById('level1TutorialOverlay').classList.add('active');
        }
        
        function startSandbox() {
            gameState.mode = GameState.SANDBOX;
            gameState.currentLevel = 0;
            
            initGrids();
            generateTerrain('valley');
            particles = [];
            interactiveElements = [];
            validPourPoints = null;
            
            document.getElementById('hud').classList.remove('active');
            hideAllOverlays();
        }
        
        function pauseGame() {
            if (gameState.mode === GameState.PLAYING) {
                gameState.mode = GameState.PAUSED;
                hideAllOverlays();
                document.getElementById('pauseOverlay').classList.add('active');
            }
        }
        
        function resumeGame() {
            if (gameState.mode === GameState.PAUSED) {
                gameState.mode = GameState.PLAYING;
                hideAllOverlays();
            }
        }
        
        function restartLevel() {
            if (gameState.currentLevel > 0) {
                startLevel(gameState.currentLevel);
            }
        }
        
        function victoryLevel() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return;
            
            gameState.mode = GameState.VICTORY;
            gameState.progress.score = calculateScore();
            
            const stars = getStarCount(gameState.progress.score, level.starThresholds);
            
            if (!gameState.starsPerLevel[level.id] || stars > gameState.starsPerLevel[level.id]) {
                gameState.starsPerLevel[level.id] = stars;
            }
            
            if (!gameState.scorePerLevel[level.id] || gameState.progress.score > gameState.scorePerLevel[level.id]) {
                gameState.scorePerLevel[level.id] = gameState.progress.score;
            }
            
            if (level.id < levels.length && !gameState.unlockedLevels.includes(level.id + 1)) {
                gameState.unlockedLevels.push(level.id + 1);
            }
            
            saveProgress();
            
            const starDisplay = '‚≠ê'.repeat(stars);
            document.getElementById('victoryStars').textContent = starDisplay;
            document.getElementById('victoryScore').textContent = gameState.progress.score;
            document.getElementById('victoryBest').textContent = `Best: ${gameState.scorePerLevel[level.id]}`;
            
            const efficiency = level.constraints.budget !== Infinity ?
                Math.floor((1 - gameState.progress.lavaUsed / level.constraints.budget) * 100) : 100;
            document.getElementById('victoryEfficiency').textContent = `${efficiency}%`;
            
            if (level.constraints.timeLimit) {
                document.getElementById('victoryTimeDiv').style.display = 'block';
                document.getElementById('victoryTime').textContent = `${gameState.progress.timeElapsed.toFixed(1)}s`;
            } else {
                document.getElementById('victoryTimeDiv').style.display = 'none';
            }
            
            document.getElementById('victoryOverlay').classList.add('active');
            
            document.getElementById('nextLevelBtn').disabled = level.id >= levels.length;
        }
        
        function defeatLevel(reason) {
            gameState.mode = GameState.DEFEAT;
            document.getElementById('defeatReason').textContent = reason;
            document.getElementById('defeatOverlay').classList.add('active');
        }
        
        function updateHUD() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return;
            
            const budgetText = level.constraints.budget === Infinity ?
                '‚àû' : `${gameState.progress.lavaUsed.toFixed(1)}/${level.constraints.budget}`;
            document.getElementById('hudLava').textContent = budgetText;

            if (level.constraints.budget !== Infinity) {
                const lavaRemaining = level.constraints.budget - gameState.progress.lavaUsed;
                const percentRemaining = (lavaRemaining / level.constraints.budget) * 100;
                if (percentRemaining < 25) {
                    document.getElementById('hudLava').classList.add('low-budget');
                } else {
                    document.getElementById('hudLava').classList.remove('low-budget');
                }
            }
            
            if (level.constraints.timeLimit) {
                document.getElementById('hudTime').textContent = `${gameState.progress.timeElapsed.toFixed(1)}s`;
            }
            
            const currentScore = calculateScore();
            document.getElementById('hudScore').textContent = currentScore;
            
            const stars = getStarCount(currentScore, level.starThresholds);
            document.getElementById('hudStars').textContent = `${'‚≠ê'.repeat(stars)}${' ‚òÜ'.repeat(3 - stars)}`;
        }
        
        function showMenu() {
            gameState.mode = GameState.MENU;
            document.getElementById('hud').classList.remove('active');
            hideAllOverlays();
            document.getElementById('menuOverlay').classList.add('active');
            
            const totalStars = Object.values(gameState.starsPerLevel).reduce((a, b) => a + b, 0);
            document.getElementById('menuStars').textContent = `Total Stars: ${'‚≠ê'.repeat(totalStars)} ${totalStars}/${levels.length * 3}`;
        }
        
        function showLevelSelect() {
            gameState.mode = GameState.LEVEL_SELECT;
            hideAllOverlays();
            
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';
            
            let currentAct = '';
            
            levels.forEach((level, index) => {
                if (level.act !== currentAct) {
                    currentAct = level.act;
                    const separator = document.createElement('div');
                    separator.className = 'act-separator';
                    separator.textContent = `Act ${Math.floor(index / 4) + 1}: ${level.act}`;
                    grid.appendChild(separator);
                }
                
                const card = document.createElement('div');
                card.className = 'level-card';
                
                const unlocked = gameState.unlockedLevels.includes(level.id);
                if (!unlocked) {
                    card.classList.add('locked');
                }
                
                const stars = gameState.starsPerLevel[level.id] || 0;
                const score = gameState.scorePerLevel[level.id] || 0;
                
                card.innerHTML = `
                    <h3>${unlocked ? '' : 'üîí '}Level ${level.id}</h3>
                    <div>${level.name}</div>
                    <div class="stars">${unlocked ? '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars) : 'üîíüîíüîí'}</div>
                    <div class="score">${unlocked && score > 0 ? `Best: ${score}` : '-'}</div>
                `;
                
                if (unlocked) {
                    card.addEventListener('click', () => {
                        startLevel(level.id);
                    });
                }
                
                grid.appendChild(card);
            });
            
            document.getElementById('levelSelectOverlay').classList.add('active');
        }

        function showInstructions() {
            hideAllOverlays();
            document.getElementById('instructionsOverlay').classList.add('active');
        }
        
        function hideAllOverlays() {
            document.querySelectorAll('.overlay').forEach(o => o.classList.remove('active'));
        }
        
        // ==================== LOCAL STORAGE ====================
        
        function saveProgress() {
            const data = {
                version: 1,
                unlockedLevels: gameState.unlockedLevels,
                starsPerLevel: gameState.starsPerLevel,
                scorePerLevel: gameState.scorePerLevel,
                level1TutorialShown: gameState.progress.level1TutorialShown
            };
            localStorage.setItem('lavaFlowProgress', JSON.stringify(data));
        }
        
        function loadProgress() {
            const saved = localStorage.getItem('lavaFlowProgress');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    gameState.unlockedLevels = data.unlockedLevels || [1];
                    gameState.starsPerLevel = data.starsPerLevel || {};
                    gameState.scorePerLevel = data.scorePerLevel || {};
                    gameState.progress.level1TutorialShown = data.level1TutorialShown || false;
                } catch (e) {
                    console.error('Failed to load progress:', e);
                }
            }
        }
        
        // ==================== INPUT HANDLING ====================
        
        canvas.addEventListener('mousedown', (e) => {
            if (gameState.mode === GameState.PLAYING) {
                const cellSize = Math.min(canvas.width, canvas.height) / GRID_SIZE;
                const offsetX = (canvas.width - GRID_SIZE * cellSize) / 2;
                const offsetY = (canvas.height - GRID_SIZE * cellSize) / 2;
                const gridX = Math.floor((e.clientX - offsetX) / cellSize);
                const gridY = Math.floor((e.clientY - offsetY) / cellSize);
                
                let handled = false;
                for (const elem of interactiveElements) {
                    if (elem.type === 'gate') {
                        const centerX = elem.x + elem.width / 2;
                        const centerY = elem.y + elem.height / 2;
                        const dist = Math.sqrt(Math.pow(gridX - centerX, 2) + Math.pow(gridY - centerY, 2));
                        if (dist < 5) {
                            elem.open = !elem.open;
                            handled = true;
                            break;
                        }
                    }
                }
                
                if (!handled) {
                    isPouring = true;
                    canvas.classList.add('pouring');
                    pourX = e.clientX;
                    pourY = e.clientY;
                    pourLava(pourX, pourY);
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isPouring && gameState.mode === GameState.PLAYING) {
                pourX = e.clientX;
                pourY = e.clientY;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isPouring = false;
            canvas.classList.remove('pouring');
        });
        
        canvas.addEventListener('mouseleave', () => {
            isPouring = false;
            canvas.classList.remove('pouring');
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.mode === GameState.PLAYING) {
                const touch = e.touches[0];
                const cellSize = Math.min(canvas.width, canvas.height) / GRID_SIZE;
                const offsetX = (canvas.width - GRID_SIZE * cellSize) / 2;
                const offsetY = (canvas.height - GRID_SIZE * cellSize) / 2;
                const gridX = Math.floor((touch.clientX - offsetX) / cellSize);
                const gridY = Math.floor((touch.clientY - offsetY) / cellSize);
                
                let handled = false;
                for (const elem of interactiveElements) {
                    if (elem.type === 'gate') {
                        const centerX = elem.x + elem.width / 2;
                        const centerY = elem.y + elem.height / 2;
                        const dist = Math.sqrt(Math.pow(gridX - centerX, 2) + Math.pow(gridY - centerY, 2));
                        if (dist < 5) {
                            elem.open = !elem.open;
                            handled = true;
                            break;
                        }
                    }
                }
                
                if (!handled) {
                    isPouring = true;
                    canvas.classList.add('pouring');
                    pourX = touch.clientX;
                    pourY = touch.clientY;
                    pourLava(pourX, pourY);
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isPouring && gameState.mode === GameState.PLAYING) {
                const touch = e.touches[0];
                pourX = touch.clientX;
                pourY = touch.clientY;
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isPouring = false;
            canvas.classList.remove('pouring');
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isPouring = false;
            canvas.classList.remove('pouring');
        });
        
        // ==================== UI BUTTON HANDLERS ====================
        
        document.getElementById('continueBtn').addEventListener('click', () => {
            const lastUnlocked = Math.max(...gameState.unlockedLevels);
            startLevel(lastUnlocked);
        });
        
        document.getElementById('levelSelectBtn').addEventListener('click', showLevelSelect);
        document.getElementById('sandboxBtn').addEventListener('click', startSandbox);
        document.getElementById('instructionsBtn').addEventListener('click', showInstructions);
        document.getElementById('backToMenuBtn').addEventListener('click', showMenu);
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            if (gameState.mode === GameState.PLAYING) {
                pauseGame();
            } else if (gameState.mode === GameState.PAUSED) {
                resumeGame();
            }
        });

        document.getElementById('resumeBtn').addEventListener('click', resumeGame);
        document.getElementById('pauseRestartBtn').addEventListener('click', restartLevel);
        document.getElementById('pauseMenuBtn').addEventListener('click', showMenu);
        document.getElementById('pauseInstructionsBtn').addEventListener('click', showInstructions);
        document.getElementById('closeInstructionsBtn').addEventListener('click', () => {
            if (gameState.mode === GameState.PAUSED) {
                hideAllOverlays();
                document.getElementById('pauseOverlay').classList.add('active');
            } else {
                showMenu();
            }
        });
        
        document.getElementById('startLevel1TutorialBtn').addEventListener('click', () => {
            gameState.progress.level1TutorialShown = true;
            saveProgress();
            startLevel(1);
        });
        
        document.getElementById('restartBtn').addEventListener('click', restartLevel);
        document.getElementById('menuBtn').addEventListener('click', showMenu);
        
        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            const nextLevel = gameState.currentLevel + 1;
            if (nextLevel <= levels.length) {
                startLevel(nextLevel);
            }
        });
        
        document.getElementById('retryBtn').addEventListener('click', restartLevel);
        document.getElementById('victoryMenuBtn').addEventListener('click', showMenu);
        document.getElementById('defeatRetryBtn').addEventListener('click', restartLevel);
        document.getElementById('defeatMenuBtn').addEventListener('click', showMenu);
        
        // ==================== GAME LOOP ====================
        
        function gameLoop() {
            const now = Date.now();
            const delta = (now - lastFrameTime) / 1000;
            lastFrameTime = now;
            
            if (gameState.mode === GameState.PLAYING) {
                simulateLava();
                
                if (isPouring) {
                    pourLava(pourX, pourY);
                }
                
                gameState.progress.timeElapsed += delta;
                
                const level = levels[gameState.currentLevel - 1];
                if (level) {
                    if (level.constraints.budget !== Infinity && 
                        gameState.progress.lavaUsed > level.constraints.budget) {
                        defeatLevel('üíß Lava budget exhausted');
                    }
                    
                    if (level.constraints.timeLimit && 
                        gameState.progress.timeElapsed > level.constraints.timeLimit) {
                        defeatLevel('‚è±Ô∏è Time limit exceeded');
                    }
                    
                    if (checkDangerZones()) {
                        defeatLevel('üö® Contaminated danger zone!');
                    }
                    
                    checkSequenceProgress();
                    
                    if (checkObjectiveComplete()) {
                        victoryLevel();
                    }
                    
                    updateHUD();
                }
            } else if (gameState.mode === GameState.SANDBOX) {
                simulateLava();
                
                if (isPouring) {
                    pourLava(pourX, pourY);
                }
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== INITIALIZATION ====================
        
        loadProgress();
        initGrids();
        generateTerrain('valley');
        lastFrameTime = Date.now();
        gameLoop();
    </script>
</body>
</html>
