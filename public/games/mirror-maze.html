<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mirror Maze - Harmonic Resonance</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            color: #00f0ff;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            background: #0a0a0f;
            cursor: crosshair;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(10,10,15,0.9), transparent);
            pointer-events: none;
        }
        
        #ui > * {
            pointer-events: auto;
        }
        
        .level-info {
            font-size: 18px;
            text-shadow: 0 0 10px #00f0ff;
            margin-bottom: 5px;
        }
        
        .target-status {
            font-size: 14px;
            color: #00ff88;
            text-shadow: 0 0 8px #00ff88;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10,10,15,0.95);
            padding: 40px;
            border: 2px solid #00f0ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,240,255,0.5);
            max-width: 90%;
        }
        
        #menu h1 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00f0ff;
            animation: pulse 2s infinite;
        }
        
        #menu h2 {
            font-size: 18px;
            color: #ff00aa;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #ff00aa;
        }
        
        .button {
            display: block;
            margin: 15px auto;
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            color: #0a0a0f;
            background: #00f0ff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: none;
            box-shadow: 0 0 20px rgba(0,240,255,0.6);
            transition: all 0.3s;
            min-width: 200px;
        }
        
        .button:hover {
            background: #00ffaa;
            box-shadow: 0 0 30px rgba(0,255,170,0.8);
            transform: scale(1.05);
        }
        
        .button.secondary {
            background: #ff00aa;
            box-shadow: 0 0 20px rgba(255,0,170,0.6);
        }
        
        .button.secondary:hover {
            background: #ff44cc;
            box-shadow: 0 0 30px rgba(255,0,170,0.8);
        }
        
        #levelSelect {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        .level-button {
            padding: 20px 10px;
            font-size: 16px;
            min-width: 0;
        }
        
        .level-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .instructions {
            margin-top: 20px;
            font-size: 14px;
            color: #00ff88;
            text-align: left;
            line-height: 1.6;
        }
        
        .instructions strong {
            color: #ff00aa;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .complete-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10,10,15,0.95);
            padding: 30px;
            border: 2px solid #00ff88;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0,255,136,0.7);
        }
        
        .complete-overlay h2 {
            color: #00ff88;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #00ff88;
        }
        
        @media (max-width: 600px) {
            #menu h1 { font-size: 28px; }
            .button { font-size: 16px; padding: 12px 30px; }
            #menu { padding: 30px 20px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="level-info">Level <span id="levelNum">1</span></div>
        <div class="target-status">Targets: <span id="targetCount">0/0</span></div>
    </div>
    
    <div id="menu">
        <h1>MIRROR MAZE</h1>
        <h2>∿ Harmonic Resonance ∿</h2>
        <button class="button" id="startBtn">Start Game</button>
        <button class="button" id="selectLevelBtn">Select Level</button>
        <button class="button secondary" id="instructionsBtn">How to Play</button>
        
        <div id="levelSelect" style="display:none;"></div>
        
        <div class="instructions" id="instructions" style="display:none;">
            <strong>◆ Goal:</strong> Hit all targets with laser beams<br>
            <strong>◆ Mirrors:</strong> Click/tap to place, click again to rotate<br>
            <strong>◆ Harmonic Resonance:</strong> When beams cross, they create a resonance node that emits special harmonic beams<br>
            <strong>◆ Harmonic beams:</strong> Can pass through barriers and hit harmonic targets (purple)<br>
            <strong>◆ Strategy:</strong> Plan beam paths to create intersections where needed<br><br>
            <button class="button" onclick="showMainMenu()">Back</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let currentLevel = 0;
        let gameState = 'menu';
        let mirrors = [];
        let selectedMirror = null;
        let particles = [];
        let levelComplete = false;
        
        // Resize canvas
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Level definitions
        const levels = [
            {
                name: "Tutorial",
                description: "Learn the basics",
                emitters: [{x: 100, y: height/2, angle: 0}],
                targets: [{x: width-100, y: height/2, type: 'normal'}],
                harmonicTargets: [],
                barriers: [],
                allowedMirrors: 1,
                tutorial: "Place a mirror to bounce the beam to the target"
            },
            {
                name: "First Resonance",
                description: "Create your first harmonic",
                emitters: [
                    {x: 100, y: height/3, angle: 0},
                    {x: 100, y: height*2/3, angle: 0}
                ],
                targets: [],
                harmonicTargets: [{x: width-100, y: height/2}],
                barriers: [],
                allowedMirrors: 2,
                tutorial: "Cross two beams to create a harmonic resonance"
            },
            {
                name: "Multi-Resonance",
                description: "Multiple intersections",
                emitters: [
                    {x: 100, y: height/4, angle: 0},
                    {x: 100, y: height/2, angle: 0},
                    {x: 100, y: height*3/4, angle: 0}
                ],
                targets: [{x: width-150, y: height/4, type: 'normal'}],
                harmonicTargets: [{x: width-150, y: height*3/4}],
                barriers: [],
                allowedMirrors: 4,
                tutorial: "Hit both normal and harmonic targets"
            },
            {
                name: "Barrier Puzzle",
                description: "Only harmonics pass through",
                emitters: [
                    {x: 100, y: 200, angle: 0},
                    {x: 100, y: height-200, angle: 0}
                ],
                targets: [],
                harmonicTargets: [{x: width-100, y: height/2}],
                barriers: [
                    {x: width/2 - 50, y: height/2 - 150, w: 100, h: 300}
                ],
                allowedMirrors: 3,
                tutorial: "Create harmonic beams to pass through barriers"
            },
            {
                name: "Complex Harmony",
                description: "Master the resonance",
                emitters: [
                    {x: 150, y: 150, angle: 0},
                    {x: 150, y: height/2, angle: 0},
                    {x: 150, y: height-150, angle: 0}
                ],
                targets: [
                    {x: width-150, y: 150, type: 'normal'},
                    {x: width-150, y: height-150, type: 'normal'}
                ],
                harmonicTargets: [
                    {x: width/2, y: height/2}
                ],
                barriers: [
                    {x: width/2 - 100, y: height/2 - 200, w: 50, h: 150},
                    {x: width/2 + 50, y: height/2 + 50, w: 50, h: 150}
                ],
                allowedMirrors: 5,
                tutorial: "Orchestrate multiple beams for perfect harmony"
            }
        ];
        
        // Load progress
        function loadProgress() {
            const saved = localStorage.getItem('mirrorMazeProgress');
            return saved ? parseInt(saved) : 0;
        }
        
        function saveProgress(level) {
            const current = loadProgress();
            if (level > current) {
                localStorage.setItem('mirrorMazeProgress', level.toString());
            }
        }
        
        // Menu functions
        function showMainMenu() {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('levelSelect').style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('selectLevelBtn').style.display = 'block';
            document.getElementById('instructionsBtn').style.display = 'block';
        }
        
        function showLevelSelect() {
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('selectLevelBtn').style.display = 'none';
            document.getElementById('instructionsBtn').style.display = 'none';
            
            const container = document.getElementById('levelSelect');
            container.innerHTML = '';
            container.style.display = 'grid';
            
            const unlockedLevel = loadProgress();
            
            levels.forEach((level, i) => {
                const btn = document.createElement('button');
                btn.className = 'button level-button';
                btn.textContent = `Level ${i+1}`;
                btn.disabled = i > unlockedLevel;
                btn.onclick = () => {
                    currentLevel = i;
                    startGame();
                };
                container.appendChild(btn);
            });
            
            const backBtn = document.createElement('button');
            backBtn.className = 'button secondary';
            backBtn.textContent = 'Back';
            backBtn.style.gridColumn = '1 / -1';
            backBtn.onclick = showMainMenu;
            container.appendChild(backBtn);
        }
        
        document.getElementById('startBtn').onclick = () => {
            currentLevel = loadProgress();
            startGame();
        };
        
        document.getElementById('selectLevelBtn').onclick = showLevelSelect;
        
        document.getElementById('instructionsBtn').onclick = () => {
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('selectLevelBtn').style.display = 'none';
            document.getElementById('instructionsBtn').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
        };
        
        function startGame() {
            gameState = 'playing';
            document.getElementById('menu').style.display = 'none';
            mirrors = [];
            levelComplete = false;
            loadLevel(currentLevel);
        }
        
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            document.getElementById('levelNum').textContent = levelIndex + 1;
            updateTargetDisplay();
        }
        
        function updateTargetDisplay() {
            const level = levels[currentLevel];
            const totalTargets = level.targets.length + level.harmonicTargets.length;
            const hitTargets = countHitTargets();
            document.getElementById('targetCount').textContent = `${hitTargets}/${totalTargets}`;
        }
        
        // Mirror class
        class Mirror {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 45; // degrees
                this.length = 60;
                this.dragging = false;
            }
            
            rotate() {
                this.angle = (this.angle + 45) % 360;
            }
            
            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                return dist < 30;
            }
            
            getLine() {
                const rad = this.angle * Math.PI / 180;
                const dx = Math.cos(rad) * this.length / 2;
                const dy = Math.sin(rad) * this.length / 2;
                return {
                    x1: this.x - dx,
                    y1: this.y - dy,
                    x2: this.x + dx,
                    y2: this.y + dy
                };
            }
            
            draw() {
                const line = this.getLine();
                ctx.strokeStyle = '#ff00aa';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff00aa';
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Draw center dot
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Particle system
        class Particle {
            constructor(x, y, color, isResonance = false) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * (isResonance ? 3 : 2);
                this.vy = (Math.random() - 0.5) * (isResonance ? 3 : 2);
                this.life = 1;
                this.decay = isResonance ? 0.02 : 0.03;
                this.color = color;
                this.size = isResonance ? 3 : 2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                return this.life > 0;
            }
            
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
        }
        
        // Ray casting and beam physics
        function castRay(x, y, angle, isHarmonic = false, depth = 0, visitedMirrors = new Set()) {
            if (depth > 20) return [];
            
            const segments = [];
            const rad = angle * Math.PI / 180;
            const dx = Math.cos(rad);
            const dy = Math.sin(rad);
            
            let closestDist = Infinity;
            let closestPoint = null;
            let closestMirror = null;
            
            // Check mirror intersections
            mirrors.forEach((mirror, index) => {
                if (visitedMirrors.has(index)) return;
                
                const line = mirror.getLine();
                const hit = lineIntersection(
                    x, y, x + dx * 5000, y + dy * 5000,
                    line.x1, line.y1, line.x2, line.y2
                );
                
                if (hit) {
                    const dist = Math.sqrt((hit.x - x)**2 + (hit.y - y)**2);
                    if (dist > 1 && dist < closestDist) {
                        closestDist = dist;
                        closestPoint = hit;
                        closestMirror = {mirror, index};
                    }
                }
            });
            
            // Check barrier intersections (only block non-harmonic beams)
            if (!isHarmonic) {
                const level = levels[currentLevel];
                level.barriers.forEach(barrier => {
                    const hits = [
                        lineIntersection(x, y, x + dx * 5000, y + dy * 5000,
                            barrier.x, barrier.y, barrier.x + barrier.w, barrier.y),
                        lineIntersection(x, y, x + dx * 5000, y + dy * 5000,
                            barrier.x + barrier.w, barrier.y, barrier.x + barrier.w, barrier.y + barrier.h),
                        lineIntersection(x, y, x + dx * 5000, y + dy * 5000,
                            barrier.x + barrier.w, barrier.y + barrier.h, barrier.x, barrier.y + barrier.h),
                        lineIntersection(x, y, x + dx * 5000, y + dy * 5000,
                            barrier.x, barrier.y + barrier.h, barrier.x, barrier.y)
                    ].filter(h => h);
                    
                    hits.forEach(hit => {
                        const dist = Math.sqrt((hit.x - x)**2 + (hit.y - y)**2);
                        if (dist > 1 && dist < closestDist) {
                            closestDist = dist;
                            closestPoint = hit;
                            closestMirror = null; // Hit barrier, stop
                        }
                    });
                });
            }
            
            // End point
            let endX, endY;
            if (closestPoint) {
                endX = closestPoint.x;
                endY = closestPoint.y;
            } else {
                endX = x + dx * 5000;
                endY = y + dy * 5000;
                
                // Clamp to canvas
                if (endX < 0 || endX > width || endY < 0 || endY > height) {
                    const t = Math.min(
                        endX < 0 ? -x/dx : endX > width ? (width-x)/dx : Infinity,
                        endY < 0 ? -y/dy : endY > height ? (height-y)/dy : Infinity
                    );
                    endX = x + dx * t;
                    endY = y + dy * t;
                }
            }
            
            segments.push({x1: x, y1: y, x2: endX, y2: endY, isHarmonic});
            
            // Reflect if hit mirror
            if (closestMirror) {
                const newVisited = new Set(visitedMirrors);
                newVisited.add(closestMirror.index);
                
                const mirrorAngle = closestMirror.mirror.angle;
                const newAngle = 2 * mirrorAngle - angle;
                
                const reflected = castRay(endX, endY, newAngle, isHarmonic, depth + 1, newVisited);
                segments.push(...reflected);
            }
            
            return segments;
        }
        
        function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.001) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            return null;
        }
        
        function findBeamIntersections(beamSegments) {
            const intersections = [];
            
            for (let i = 0; i < beamSegments.length; i++) {
                for (let j = i + 1; j < beamSegments.length; j++) {
                    const s1 = beamSegments[i];
                    const s2 = beamSegments[j];
                    
                    const hit = lineIntersection(
                        s1.x1, s1.y1, s1.x2, s1.y2,
                        s2.x1, s2.y1, s2.x2, s2.y2
                    );
                    
                    if (hit) {
                        // Check if this intersection is new
                        const existing = intersections.find(p => 
                            Math.abs(p.x - hit.x) < 5 && Math.abs(p.y - hit.y) < 5
                        );
                        if (!existing) {
                            intersections.push({x: hit.x, y: hit.y, count: 2});
                        } else {
                            existing.count++;
                        }
                    }
                }
            }
            
            return intersections;
        }
        
        function countHitTargets() {
            const level = levels[currentLevel];
            const beamSegments = [];
            
            // Collect all beam segments
            level.emitters.forEach(emitter => {
                const segments = castRay(emitter.x, emitter.y, emitter.angle, false);
                beamSegments.push(...segments);
            });
            
            // Find intersections and add harmonic beams
            const intersections = findBeamIntersections(beamSegments);
            intersections.forEach(point => {
                for (let a = 0; a < 360; a += 45) {
                    const harmonicSegments = castRay(point.x, point.y, a, true, 0, new Set());
                    beamSegments.push(...harmonicSegments);
                }
            });
            
            let hitCount = 0;
            
            // Check normal targets
            level.targets.forEach(target => {
                const hit = beamSegments.some(seg => {
                    if (seg.isHarmonic) return false;
                    const dist = pointToLineDistance(target.x, target.y, seg.x1, seg.y1, seg.x2, seg.y2);
                    return dist < 15;
                });
                if (hit) hitCount++;
            });
            
            // Check harmonic targets
            level.harmonicTargets.forEach(target => {
                const hit = beamSegments.some(seg => {
                    if (!seg.isHarmonic) return false;
                    const dist = pointToLineDistance(target.x, target.y, seg.x1, seg.y1, seg.x2, seg.y2);
                    return dist < 15;
                });
                if (hit) hitCount++;
            });
            
            return hitCount;
        }
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len === 0) return Math.sqrt((px-x1)**2 + (py-y1)**2);
            
            const t = Math.max(0, Math.min(1, ((px-x1)*dx + (py-y1)*dy) / (len*len)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px-projX)**2 + (py-projY)**2);
        }
        
        // Drawing functions
        function drawLevel() {
            const level = levels[currentLevel];
            
            // Draw barriers
            level.barriers.forEach(barrier => {
                ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
                ctx.strokeStyle = '#6666aa';
                ctx.lineWidth = 2;
                ctx.fillRect(barrier.x, barrier.y, barrier.w, barrier.h);
                ctx.strokeRect(barrier.x, barrier.y, barrier.w, barrier.h);
                
                // Draw barrier pattern
                ctx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < barrier.w; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(barrier.x + i, barrier.y);
                    ctx.lineTo(barrier.x + i, barrier.y + barrier.h);
                    ctx.stroke();
                }
            });
            
            // Draw emitters
            level.emitters.forEach(emitter => {
                ctx.fillStyle = '#ffaa00';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffaa00';
                ctx.beginPath();
                ctx.arc(emitter.x, emitter.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw mirrors
            mirrors.forEach(mirror => mirror.draw());
            
            // Cast and draw beams
            const beamSegments = [];
            level.emitters.forEach(emitter => {
                const segments = castRay(emitter.x, emitter.y, emitter.angle, false);
                beamSegments.push(...segments);
            });
            
            // Find intersections
            const intersections = findBeamIntersections(beamSegments);
            
            // Draw resonance nodes and harmonic beams
            intersections.forEach(point => {
                // Add harmonic beams from this node
                for (let a = 0; a < 360; a += 45) {
                    const harmonicSegments = castRay(point.x, point.y, a, true, 0, new Set());
                    beamSegments.push(...harmonicSegments);
                }
                
                // Spawn particles
                if (Math.random() < 0.3) {
                    const color = point.count > 2 ? '#ffff00' : '#ffffff';
                    particles.push(new Particle(point.x, point.y, color, true));
                }
            });
            
            // Draw beams
            beamSegments.forEach(seg => {
                if (seg.isHarmonic) {
                    // Harmonic beam (purple-gold gradient)
                    const gradient = ctx.createLinearGradient(seg.x1, seg.y1, seg.x2, seg.y2);
                    gradient.addColorStop(0, '#aa00ff');
                    gradient.addColorStop(0.5, '#ff00aa');
                    gradient.addColorStop(1, '#ffaa00');
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff00aa';
                } else {
                    // Normal beam (cyan)
                    ctx.strokeStyle = '#00f0ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00f0ff';
                }
                
                ctx.beginPath();
                ctx.moveTo(seg.x1, seg.y1);
                ctx.lineTo(seg.x2, seg.y2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Sparkles on harmonic beams
                if (seg.isHarmonic && Math.random() < 0.05) {
                    const t = Math.random();
                    const x = seg.x1 + (seg.x2 - seg.x1) * t;
                    const y = seg.y1 + (seg.y2 - seg.y1) * t;
                    particles.push(new Particle(x, y, '#ffaa00', false));
                }
            });
            
            // Draw resonance nodes
            intersections.forEach(point => {
                const size = 10 + point.count * 3;
                const color = point.count > 2 ? '#ffff00' : '#ffffff';
                
                ctx.fillStyle = color;
                ctx.shadowBlur = 25;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(point.x, point.y, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw targets
            level.targets.forEach(target => {
                const hit = beamSegments.some(seg => {
                    if (seg.isHarmonic) return false;
                    const dist = pointToLineDistance(target.x, target.y, seg.x1, seg.y1, seg.x2, seg.y2);
                    return dist < 15;
                });
                
                ctx.strokeStyle = hit ? '#00ff00' : '#00ff88';
                ctx.fillStyle = hit ? 'rgba(0, 255, 0, 0.3)' : 'rgba(0, 255, 136, 0.1)';
                ctx.lineWidth = 3;
                ctx.shadowBlur = hit ? 20 : 10;
                ctx.shadowColor = hit ? '#00ff00' : '#00ff88';
                
                ctx.beginPath();
                ctx.arc(target.x, target.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
            
            // Draw harmonic targets
            level.harmonicTargets.forEach(target => {
                const hit = beamSegments.some(seg => {
                    if (!seg.isHarmonic) return false;
                    const dist = pointToLineDistance(target.x, target.y, seg.x1, seg.y1, seg.x2, seg.y2);
                    return dist < 15;
                });
                
                ctx.strokeStyle = hit ? '#ff00ff' : '#aa00ff';
                ctx.fillStyle = hit ? 'rgba(255, 0, 255, 0.3)' : 'rgba(170, 0, 255, 0.1)';
                ctx.lineWidth = 3;
                ctx.shadowBlur = hit ? 20 : 10;
                ctx.shadowColor = hit ? '#ff00ff' : '#aa00ff';
                
                ctx.beginPath();
                ctx.arc(target.x, target.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Inner star for harmonic targets
                ctx.fillStyle = hit ? '#ffff00' : '#ff00aa';
                ctx.shadowBlur = 0;
                drawStar(target.x, target.y, 5, 6, 3);
            });
        }
        
        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }
        
        function checkLevelComplete() {
            const level = levels[currentLevel];
            const totalTargets = level.targets.length + level.harmonicTargets.length;
            const hitTargets = countHitTargets();
            
            if (hitTargets === totalTargets && totalTargets > 0 && !levelComplete) {
                levelComplete = true;
                saveProgress(currentLevel + 1);
                
                setTimeout(() => {
                    if (currentLevel < levels.length - 1) {
                        // Next level
                        currentLevel++;
                        mirrors = [];
                        levelComplete = false;
                        loadLevel(currentLevel);
                    } else {
                        // Game complete
                        showGameComplete();
                    }
                }, 1500);
            }
        }
        
        function showGameComplete() {
            gameState = 'menu';
            const menu = document.getElementById('menu');
            menu.innerHTML = `
                <div class="complete-overlay">
                    <h2>✧ ALL HARMONICS MASTERED ✧</h2>
                    <p style="color: #00f0ff; margin: 20px 0;">You've completed all levels!</p>
                    <button class="button" onclick="location.reload()">Play Again</button>
                </div>
            `;
            menu.style.display = 'block';
        }
        
        // Input handling
        function getInputPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: (touch.clientX - rect.left) * (width / rect.width),
                y: (touch.clientY - rect.top) * (height / rect.height)
            };
        }
        
        function handlePointerDown(e) {
            if (gameState !== 'playing') return;
            e.preventDefault();
            
            const pos = getInputPos(e);
            
            // Check if clicking existing mirror
            const clicked = mirrors.find(m => m.contains(pos.x, pos.y));
            if (clicked) {
                clicked.rotate();
                return;
            }
            
            // Place new mirror
            const level = levels[currentLevel];
            if (mirrors.length < level.allowedMirrors) {
                mirrors.push(new Mirror(pos.x, pos.y));
            }
        }
        
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', handlePointerDown);
        
        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, width, height);
            
            if (gameState === 'playing') {
                drawLevel();
                
                // Update and draw particles
                particles = particles.filter(p => {
                    const alive = p.update();
                    if (alive) p.draw();
                    return alive;
                });
                
                updateTargetDisplay();
                checkLevelComplete();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>